package api

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"time"
)

type Cve struct {
	AffectedCve     string `json:"affectedCve"`
	Severity        string `json:"severity"`
	SupportProducts string `json:"supportProducts"`
	Title           string `json:"title"`
	Status          string `json:"status"`
	DocumentID      string `json:"documentId"`
	Published       string `json:"published"`
	Updated         string `json:"updated"`
	NotificationURL string `json:"notificationUrl"`
	WorkAround      string `json:"workAround"`
}

type CveResponse struct {
	Success bool `json:"success"`
	Data    struct {
		List     []Cve `json:"list"`
		PageInfo struct {
			TotalCount  int    `json:"totalCount"`
			CurrentPage int    `json:"currentPage"`
			SortBy      string `json:"sortBy"`
			PageSize    int    `json:"pageSize"`
			NextPage    int    `json:"nextPage"`
			LastPage    int    `json:"lastPage"`
			FirstPage   int    `json:"firstPage"`
		} `json:"pageInfo"`
	} `json:"data"`
	CorrelationID string `json:"correlationId"`
}

var ErrorInvalidCookie = errors.New("cookie is not valid")

func Fetch() (allProductCves map[string][]Cve, err error) {
	allProductCves = make(map[string][]Cve)

	products := map[string]string{
		"BSN": "Brocade",
		"ES":  "Enterprise-Software",
		"MF":  "Mainframe",
		"PZ":  "Payment-Security",
		"SE":  "Cyber-Security",
		"VA":  "App-Networking-Security",
		"VC":  "VMware-Cloud-Foundation",
		"VE":  "Software-Defined-Edge",
		"VT":  "Tanzu",
	}

	client := http.Client{Timeout: 5 * time.Second}

	for productCode, productName := range products {
		postJsonString := fmt.Sprintf(
			`{"pageNumber": 0, "pageSize": 10000, "searchVal": "", "segment": "%s", "sortInfo": {"column": "", "order": ""}}`,
			productCode)
		postJson := bytes.NewBuffer([]byte(postJsonString))
		req, _ := http.NewRequest("POST",
			"https://support.broadcom.com/web/ecx/security-advisory/-/securityadvisory/getSecurityAdvisoryList", postJson)
		var resp *http.Response
		resp, err = client.Do(req)
		if err != nil {
			return
		}
		defer resp.Body.Close()

		var cveResponse CveResponse
		if resp.StatusCode != http.StatusOK {
			return
		}

		_ = json.NewDecoder(resp.Body).Decode(&cveResponse)
		allProductCves[productName] = cveResponse.Data.List
	}

	return
}